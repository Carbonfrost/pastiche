// Code generated by counterfeiter. DO NOT EDIT.
package modelfakes

import (
	"net/url"
	"sync"

	"github.com/Carbonfrost/pastiche/pkg/model"
)

type FakeResolvedResource struct {
	ClientStub        func() model.Client
	clientMutex       sync.RWMutex
	clientArgsForCall []struct {
	}
	clientReturns struct {
		result1 model.Client
	}
	clientReturnsOnCall map[int]struct {
		result1 model.Client
	}
	EndpointStub        func() *model.Endpoint
	endpointMutex       sync.RWMutex
	endpointArgsForCall []struct {
	}
	endpointReturns struct {
		result1 *model.Endpoint
	}
	endpointReturnsOnCall map[int]struct {
		result1 *model.Endpoint
	}
	EvalRequestStub        func(*url.URL, map[string]any) (model.Request, error)
	evalRequestMutex       sync.RWMutex
	evalRequestArgsForCall []struct {
		arg1 *url.URL
		arg2 map[string]any
	}
	evalRequestReturns struct {
		result1 model.Request
		result2 error
	}
	evalRequestReturnsOnCall map[int]struct {
		result1 model.Request
		result2 error
	}
	LineageStub        func() []*model.Resource
	lineageMutex       sync.RWMutex
	lineageArgsForCall []struct {
	}
	lineageReturns struct {
		result1 []*model.Resource
	}
	lineageReturnsOnCall map[int]struct {
		result1 []*model.Resource
	}
	ResourceStub        func() *model.Resource
	resourceMutex       sync.RWMutex
	resourceArgsForCall []struct {
	}
	resourceReturns struct {
		result1 *model.Resource
	}
	resourceReturnsOnCall map[int]struct {
		result1 *model.Resource
	}
	ServerStub        func() *model.Server
	serverMutex       sync.RWMutex
	serverArgsForCall []struct {
	}
	serverReturns struct {
		result1 *model.Server
	}
	serverReturnsOnCall map[int]struct {
		result1 *model.Server
	}
	ServiceStub        func() *model.Service
	serviceMutex       sync.RWMutex
	serviceArgsForCall []struct {
	}
	serviceReturns struct {
		result1 *model.Service
	}
	serviceReturnsOnCall map[int]struct {
		result1 *model.Service
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeResolvedResource) Client() model.Client {
	fake.clientMutex.Lock()
	ret, specificReturn := fake.clientReturnsOnCall[len(fake.clientArgsForCall)]
	fake.clientArgsForCall = append(fake.clientArgsForCall, struct {
	}{})
	stub := fake.ClientStub
	fakeReturns := fake.clientReturns
	fake.recordInvocation("Client", []interface{}{})
	fake.clientMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResolvedResource) ClientCallCount() int {
	fake.clientMutex.RLock()
	defer fake.clientMutex.RUnlock()
	return len(fake.clientArgsForCall)
}

func (fake *FakeResolvedResource) ClientCalls(stub func() model.Client) {
	fake.clientMutex.Lock()
	defer fake.clientMutex.Unlock()
	fake.ClientStub = stub
}

func (fake *FakeResolvedResource) ClientReturns(result1 model.Client) {
	fake.clientMutex.Lock()
	defer fake.clientMutex.Unlock()
	fake.ClientStub = nil
	fake.clientReturns = struct {
		result1 model.Client
	}{result1}
}

func (fake *FakeResolvedResource) ClientReturnsOnCall(i int, result1 model.Client) {
	fake.clientMutex.Lock()
	defer fake.clientMutex.Unlock()
	fake.ClientStub = nil
	if fake.clientReturnsOnCall == nil {
		fake.clientReturnsOnCall = make(map[int]struct {
			result1 model.Client
		})
	}
	fake.clientReturnsOnCall[i] = struct {
		result1 model.Client
	}{result1}
}

func (fake *FakeResolvedResource) Endpoint() *model.Endpoint {
	fake.endpointMutex.Lock()
	ret, specificReturn := fake.endpointReturnsOnCall[len(fake.endpointArgsForCall)]
	fake.endpointArgsForCall = append(fake.endpointArgsForCall, struct {
	}{})
	stub := fake.EndpointStub
	fakeReturns := fake.endpointReturns
	fake.recordInvocation("Endpoint", []interface{}{})
	fake.endpointMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResolvedResource) EndpointCallCount() int {
	fake.endpointMutex.RLock()
	defer fake.endpointMutex.RUnlock()
	return len(fake.endpointArgsForCall)
}

func (fake *FakeResolvedResource) EndpointCalls(stub func() *model.Endpoint) {
	fake.endpointMutex.Lock()
	defer fake.endpointMutex.Unlock()
	fake.EndpointStub = stub
}

func (fake *FakeResolvedResource) EndpointReturns(result1 *model.Endpoint) {
	fake.endpointMutex.Lock()
	defer fake.endpointMutex.Unlock()
	fake.EndpointStub = nil
	fake.endpointReturns = struct {
		result1 *model.Endpoint
	}{result1}
}

func (fake *FakeResolvedResource) EndpointReturnsOnCall(i int, result1 *model.Endpoint) {
	fake.endpointMutex.Lock()
	defer fake.endpointMutex.Unlock()
	fake.EndpointStub = nil
	if fake.endpointReturnsOnCall == nil {
		fake.endpointReturnsOnCall = make(map[int]struct {
			result1 *model.Endpoint
		})
	}
	fake.endpointReturnsOnCall[i] = struct {
		result1 *model.Endpoint
	}{result1}
}

func (fake *FakeResolvedResource) EvalRequest(arg1 *url.URL, arg2 map[string]any) (model.Request, error) {
	fake.evalRequestMutex.Lock()
	ret, specificReturn := fake.evalRequestReturnsOnCall[len(fake.evalRequestArgsForCall)]
	fake.evalRequestArgsForCall = append(fake.evalRequestArgsForCall, struct {
		arg1 *url.URL
		arg2 map[string]any
	}{arg1, arg2})
	stub := fake.EvalRequestStub
	fakeReturns := fake.evalRequestReturns
	fake.recordInvocation("EvalRequest", []interface{}{arg1, arg2})
	fake.evalRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResolvedResource) EvalRequestCallCount() int {
	fake.evalRequestMutex.RLock()
	defer fake.evalRequestMutex.RUnlock()
	return len(fake.evalRequestArgsForCall)
}

func (fake *FakeResolvedResource) EvalRequestCalls(stub func(*url.URL, map[string]any) (model.Request, error)) {
	fake.evalRequestMutex.Lock()
	defer fake.evalRequestMutex.Unlock()
	fake.EvalRequestStub = stub
}

func (fake *FakeResolvedResource) EvalRequestArgsForCall(i int) (*url.URL, map[string]any) {
	fake.evalRequestMutex.RLock()
	defer fake.evalRequestMutex.RUnlock()
	argsForCall := fake.evalRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResolvedResource) EvalRequestReturns(result1 model.Request, result2 error) {
	fake.evalRequestMutex.Lock()
	defer fake.evalRequestMutex.Unlock()
	fake.EvalRequestStub = nil
	fake.evalRequestReturns = struct {
		result1 model.Request
		result2 error
	}{result1, result2}
}

func (fake *FakeResolvedResource) EvalRequestReturnsOnCall(i int, result1 model.Request, result2 error) {
	fake.evalRequestMutex.Lock()
	defer fake.evalRequestMutex.Unlock()
	fake.EvalRequestStub = nil
	if fake.evalRequestReturnsOnCall == nil {
		fake.evalRequestReturnsOnCall = make(map[int]struct {
			result1 model.Request
			result2 error
		})
	}
	fake.evalRequestReturnsOnCall[i] = struct {
		result1 model.Request
		result2 error
	}{result1, result2}
}

func (fake *FakeResolvedResource) Lineage() []*model.Resource {
	fake.lineageMutex.Lock()
	ret, specificReturn := fake.lineageReturnsOnCall[len(fake.lineageArgsForCall)]
	fake.lineageArgsForCall = append(fake.lineageArgsForCall, struct {
	}{})
	stub := fake.LineageStub
	fakeReturns := fake.lineageReturns
	fake.recordInvocation("Lineage", []interface{}{})
	fake.lineageMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResolvedResource) LineageCallCount() int {
	fake.lineageMutex.RLock()
	defer fake.lineageMutex.RUnlock()
	return len(fake.lineageArgsForCall)
}

func (fake *FakeResolvedResource) LineageCalls(stub func() []*model.Resource) {
	fake.lineageMutex.Lock()
	defer fake.lineageMutex.Unlock()
	fake.LineageStub = stub
}

func (fake *FakeResolvedResource) LineageReturns(result1 []*model.Resource) {
	fake.lineageMutex.Lock()
	defer fake.lineageMutex.Unlock()
	fake.LineageStub = nil
	fake.lineageReturns = struct {
		result1 []*model.Resource
	}{result1}
}

func (fake *FakeResolvedResource) LineageReturnsOnCall(i int, result1 []*model.Resource) {
	fake.lineageMutex.Lock()
	defer fake.lineageMutex.Unlock()
	fake.LineageStub = nil
	if fake.lineageReturnsOnCall == nil {
		fake.lineageReturnsOnCall = make(map[int]struct {
			result1 []*model.Resource
		})
	}
	fake.lineageReturnsOnCall[i] = struct {
		result1 []*model.Resource
	}{result1}
}

func (fake *FakeResolvedResource) Resource() *model.Resource {
	fake.resourceMutex.Lock()
	ret, specificReturn := fake.resourceReturnsOnCall[len(fake.resourceArgsForCall)]
	fake.resourceArgsForCall = append(fake.resourceArgsForCall, struct {
	}{})
	stub := fake.ResourceStub
	fakeReturns := fake.resourceReturns
	fake.recordInvocation("Resource", []interface{}{})
	fake.resourceMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResolvedResource) ResourceCallCount() int {
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	return len(fake.resourceArgsForCall)
}

func (fake *FakeResolvedResource) ResourceCalls(stub func() *model.Resource) {
	fake.resourceMutex.Lock()
	defer fake.resourceMutex.Unlock()
	fake.ResourceStub = stub
}

func (fake *FakeResolvedResource) ResourceReturns(result1 *model.Resource) {
	fake.resourceMutex.Lock()
	defer fake.resourceMutex.Unlock()
	fake.ResourceStub = nil
	fake.resourceReturns = struct {
		result1 *model.Resource
	}{result1}
}

func (fake *FakeResolvedResource) ResourceReturnsOnCall(i int, result1 *model.Resource) {
	fake.resourceMutex.Lock()
	defer fake.resourceMutex.Unlock()
	fake.ResourceStub = nil
	if fake.resourceReturnsOnCall == nil {
		fake.resourceReturnsOnCall = make(map[int]struct {
			result1 *model.Resource
		})
	}
	fake.resourceReturnsOnCall[i] = struct {
		result1 *model.Resource
	}{result1}
}

func (fake *FakeResolvedResource) Server() *model.Server {
	fake.serverMutex.Lock()
	ret, specificReturn := fake.serverReturnsOnCall[len(fake.serverArgsForCall)]
	fake.serverArgsForCall = append(fake.serverArgsForCall, struct {
	}{})
	stub := fake.ServerStub
	fakeReturns := fake.serverReturns
	fake.recordInvocation("Server", []interface{}{})
	fake.serverMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResolvedResource) ServerCallCount() int {
	fake.serverMutex.RLock()
	defer fake.serverMutex.RUnlock()
	return len(fake.serverArgsForCall)
}

func (fake *FakeResolvedResource) ServerCalls(stub func() *model.Server) {
	fake.serverMutex.Lock()
	defer fake.serverMutex.Unlock()
	fake.ServerStub = stub
}

func (fake *FakeResolvedResource) ServerReturns(result1 *model.Server) {
	fake.serverMutex.Lock()
	defer fake.serverMutex.Unlock()
	fake.ServerStub = nil
	fake.serverReturns = struct {
		result1 *model.Server
	}{result1}
}

func (fake *FakeResolvedResource) ServerReturnsOnCall(i int, result1 *model.Server) {
	fake.serverMutex.Lock()
	defer fake.serverMutex.Unlock()
	fake.ServerStub = nil
	if fake.serverReturnsOnCall == nil {
		fake.serverReturnsOnCall = make(map[int]struct {
			result1 *model.Server
		})
	}
	fake.serverReturnsOnCall[i] = struct {
		result1 *model.Server
	}{result1}
}

func (fake *FakeResolvedResource) Service() *model.Service {
	fake.serviceMutex.Lock()
	ret, specificReturn := fake.serviceReturnsOnCall[len(fake.serviceArgsForCall)]
	fake.serviceArgsForCall = append(fake.serviceArgsForCall, struct {
	}{})
	stub := fake.ServiceStub
	fakeReturns := fake.serviceReturns
	fake.recordInvocation("Service", []interface{}{})
	fake.serviceMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResolvedResource) ServiceCallCount() int {
	fake.serviceMutex.RLock()
	defer fake.serviceMutex.RUnlock()
	return len(fake.serviceArgsForCall)
}

func (fake *FakeResolvedResource) ServiceCalls(stub func() *model.Service) {
	fake.serviceMutex.Lock()
	defer fake.serviceMutex.Unlock()
	fake.ServiceStub = stub
}

func (fake *FakeResolvedResource) ServiceReturns(result1 *model.Service) {
	fake.serviceMutex.Lock()
	defer fake.serviceMutex.Unlock()
	fake.ServiceStub = nil
	fake.serviceReturns = struct {
		result1 *model.Service
	}{result1}
}

func (fake *FakeResolvedResource) ServiceReturnsOnCall(i int, result1 *model.Service) {
	fake.serviceMutex.Lock()
	defer fake.serviceMutex.Unlock()
	fake.ServiceStub = nil
	if fake.serviceReturnsOnCall == nil {
		fake.serviceReturnsOnCall = make(map[int]struct {
			result1 *model.Service
		})
	}
	fake.serviceReturnsOnCall[i] = struct {
		result1 *model.Service
	}{result1}
}

func (fake *FakeResolvedResource) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeResolvedResource) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ model.ResolvedResource = new(FakeResolvedResource)
