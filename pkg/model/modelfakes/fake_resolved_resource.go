// Code generated by counterfeiter. DO NOT EDIT.
package modelfakes

import (
	"io"
	"net/http"
	"net/url"
	"sync"

	"github.com/Carbonfrost/joe-cli-http/uritemplates"
	"github.com/Carbonfrost/pastiche/pkg/model"
)

type FakeResolvedResource struct {
	BodyStub        func(uritemplates.Vars) io.ReadCloser
	bodyMutex       sync.RWMutex
	bodyArgsForCall []struct {
		arg1 uritemplates.Vars
	}
	bodyReturns struct {
		result1 io.ReadCloser
	}
	bodyReturnsOnCall map[int]struct {
		result1 io.ReadCloser
	}
	EndpointStub        func() *model.Endpoint
	endpointMutex       sync.RWMutex
	endpointArgsForCall []struct {
	}
	endpointReturns struct {
		result1 *model.Endpoint
	}
	endpointReturnsOnCall map[int]struct {
		result1 *model.Endpoint
	}
	HeaderStub        func(map[string]any) http.Header
	headerMutex       sync.RWMutex
	headerArgsForCall []struct {
		arg1 map[string]any
	}
	headerReturns struct {
		result1 http.Header
	}
	headerReturnsOnCall map[int]struct {
		result1 http.Header
	}
	ResourceStub        func() *model.Resource
	resourceMutex       sync.RWMutex
	resourceArgsForCall []struct {
	}
	resourceReturns struct {
		result1 *model.Resource
	}
	resourceReturnsOnCall map[int]struct {
		result1 *model.Resource
	}
	ServerStub        func() *model.Server
	serverMutex       sync.RWMutex
	serverArgsForCall []struct {
	}
	serverReturns struct {
		result1 *model.Server
	}
	serverReturnsOnCall map[int]struct {
		result1 *model.Server
	}
	ServiceStub        func() *model.Service
	serviceMutex       sync.RWMutex
	serviceArgsForCall []struct {
	}
	serviceReturns struct {
		result1 *model.Service
	}
	serviceReturnsOnCall map[int]struct {
		result1 *model.Service
	}
	URLStub        func(*url.URL, uritemplates.Vars) (*url.URL, error)
	uRLMutex       sync.RWMutex
	uRLArgsForCall []struct {
		arg1 *url.URL
		arg2 uritemplates.Vars
	}
	uRLReturns struct {
		result1 *url.URL
		result2 error
	}
	uRLReturnsOnCall map[int]struct {
		result1 *url.URL
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeResolvedResource) Body(arg1 uritemplates.Vars) io.ReadCloser {
	fake.bodyMutex.Lock()
	ret, specificReturn := fake.bodyReturnsOnCall[len(fake.bodyArgsForCall)]
	fake.bodyArgsForCall = append(fake.bodyArgsForCall, struct {
		arg1 uritemplates.Vars
	}{arg1})
	stub := fake.BodyStub
	fakeReturns := fake.bodyReturns
	fake.recordInvocation("Body", []interface{}{arg1})
	fake.bodyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResolvedResource) BodyCallCount() int {
	fake.bodyMutex.RLock()
	defer fake.bodyMutex.RUnlock()
	return len(fake.bodyArgsForCall)
}

func (fake *FakeResolvedResource) BodyCalls(stub func(uritemplates.Vars) io.ReadCloser) {
	fake.bodyMutex.Lock()
	defer fake.bodyMutex.Unlock()
	fake.BodyStub = stub
}

func (fake *FakeResolvedResource) BodyArgsForCall(i int) uritemplates.Vars {
	fake.bodyMutex.RLock()
	defer fake.bodyMutex.RUnlock()
	argsForCall := fake.bodyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResolvedResource) BodyReturns(result1 io.ReadCloser) {
	fake.bodyMutex.Lock()
	defer fake.bodyMutex.Unlock()
	fake.BodyStub = nil
	fake.bodyReturns = struct {
		result1 io.ReadCloser
	}{result1}
}

func (fake *FakeResolvedResource) BodyReturnsOnCall(i int, result1 io.ReadCloser) {
	fake.bodyMutex.Lock()
	defer fake.bodyMutex.Unlock()
	fake.BodyStub = nil
	if fake.bodyReturnsOnCall == nil {
		fake.bodyReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
		})
	}
	fake.bodyReturnsOnCall[i] = struct {
		result1 io.ReadCloser
	}{result1}
}

func (fake *FakeResolvedResource) Endpoint() *model.Endpoint {
	fake.endpointMutex.Lock()
	ret, specificReturn := fake.endpointReturnsOnCall[len(fake.endpointArgsForCall)]
	fake.endpointArgsForCall = append(fake.endpointArgsForCall, struct {
	}{})
	stub := fake.EndpointStub
	fakeReturns := fake.endpointReturns
	fake.recordInvocation("Endpoint", []interface{}{})
	fake.endpointMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResolvedResource) EndpointCallCount() int {
	fake.endpointMutex.RLock()
	defer fake.endpointMutex.RUnlock()
	return len(fake.endpointArgsForCall)
}

func (fake *FakeResolvedResource) EndpointCalls(stub func() *model.Endpoint) {
	fake.endpointMutex.Lock()
	defer fake.endpointMutex.Unlock()
	fake.EndpointStub = stub
}

func (fake *FakeResolvedResource) EndpointReturns(result1 *model.Endpoint) {
	fake.endpointMutex.Lock()
	defer fake.endpointMutex.Unlock()
	fake.EndpointStub = nil
	fake.endpointReturns = struct {
		result1 *model.Endpoint
	}{result1}
}

func (fake *FakeResolvedResource) EndpointReturnsOnCall(i int, result1 *model.Endpoint) {
	fake.endpointMutex.Lock()
	defer fake.endpointMutex.Unlock()
	fake.EndpointStub = nil
	if fake.endpointReturnsOnCall == nil {
		fake.endpointReturnsOnCall = make(map[int]struct {
			result1 *model.Endpoint
		})
	}
	fake.endpointReturnsOnCall[i] = struct {
		result1 *model.Endpoint
	}{result1}
}

func (fake *FakeResolvedResource) Header(arg1 map[string]any) http.Header {
	fake.headerMutex.Lock()
	ret, specificReturn := fake.headerReturnsOnCall[len(fake.headerArgsForCall)]
	fake.headerArgsForCall = append(fake.headerArgsForCall, struct {
		arg1 map[string]any
	}{arg1})
	stub := fake.HeaderStub
	fakeReturns := fake.headerReturns
	fake.recordInvocation("Header", []interface{}{arg1})
	fake.headerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResolvedResource) HeaderCallCount() int {
	fake.headerMutex.RLock()
	defer fake.headerMutex.RUnlock()
	return len(fake.headerArgsForCall)
}

func (fake *FakeResolvedResource) HeaderCalls(stub func(map[string]any) http.Header) {
	fake.headerMutex.Lock()
	defer fake.headerMutex.Unlock()
	fake.HeaderStub = stub
}

func (fake *FakeResolvedResource) HeaderArgsForCall(i int) map[string]any {
	fake.headerMutex.RLock()
	defer fake.headerMutex.RUnlock()
	argsForCall := fake.headerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResolvedResource) HeaderReturns(result1 http.Header) {
	fake.headerMutex.Lock()
	defer fake.headerMutex.Unlock()
	fake.HeaderStub = nil
	fake.headerReturns = struct {
		result1 http.Header
	}{result1}
}

func (fake *FakeResolvedResource) HeaderReturnsOnCall(i int, result1 http.Header) {
	fake.headerMutex.Lock()
	defer fake.headerMutex.Unlock()
	fake.HeaderStub = nil
	if fake.headerReturnsOnCall == nil {
		fake.headerReturnsOnCall = make(map[int]struct {
			result1 http.Header
		})
	}
	fake.headerReturnsOnCall[i] = struct {
		result1 http.Header
	}{result1}
}

func (fake *FakeResolvedResource) Resource() *model.Resource {
	fake.resourceMutex.Lock()
	ret, specificReturn := fake.resourceReturnsOnCall[len(fake.resourceArgsForCall)]
	fake.resourceArgsForCall = append(fake.resourceArgsForCall, struct {
	}{})
	stub := fake.ResourceStub
	fakeReturns := fake.resourceReturns
	fake.recordInvocation("Resource", []interface{}{})
	fake.resourceMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResolvedResource) ResourceCallCount() int {
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	return len(fake.resourceArgsForCall)
}

func (fake *FakeResolvedResource) ResourceCalls(stub func() *model.Resource) {
	fake.resourceMutex.Lock()
	defer fake.resourceMutex.Unlock()
	fake.ResourceStub = stub
}

func (fake *FakeResolvedResource) ResourceReturns(result1 *model.Resource) {
	fake.resourceMutex.Lock()
	defer fake.resourceMutex.Unlock()
	fake.ResourceStub = nil
	fake.resourceReturns = struct {
		result1 *model.Resource
	}{result1}
}

func (fake *FakeResolvedResource) ResourceReturnsOnCall(i int, result1 *model.Resource) {
	fake.resourceMutex.Lock()
	defer fake.resourceMutex.Unlock()
	fake.ResourceStub = nil
	if fake.resourceReturnsOnCall == nil {
		fake.resourceReturnsOnCall = make(map[int]struct {
			result1 *model.Resource
		})
	}
	fake.resourceReturnsOnCall[i] = struct {
		result1 *model.Resource
	}{result1}
}

func (fake *FakeResolvedResource) Server() *model.Server {
	fake.serverMutex.Lock()
	ret, specificReturn := fake.serverReturnsOnCall[len(fake.serverArgsForCall)]
	fake.serverArgsForCall = append(fake.serverArgsForCall, struct {
	}{})
	stub := fake.ServerStub
	fakeReturns := fake.serverReturns
	fake.recordInvocation("Server", []interface{}{})
	fake.serverMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResolvedResource) ServerCallCount() int {
	fake.serverMutex.RLock()
	defer fake.serverMutex.RUnlock()
	return len(fake.serverArgsForCall)
}

func (fake *FakeResolvedResource) ServerCalls(stub func() *model.Server) {
	fake.serverMutex.Lock()
	defer fake.serverMutex.Unlock()
	fake.ServerStub = stub
}

func (fake *FakeResolvedResource) ServerReturns(result1 *model.Server) {
	fake.serverMutex.Lock()
	defer fake.serverMutex.Unlock()
	fake.ServerStub = nil
	fake.serverReturns = struct {
		result1 *model.Server
	}{result1}
}

func (fake *FakeResolvedResource) ServerReturnsOnCall(i int, result1 *model.Server) {
	fake.serverMutex.Lock()
	defer fake.serverMutex.Unlock()
	fake.ServerStub = nil
	if fake.serverReturnsOnCall == nil {
		fake.serverReturnsOnCall = make(map[int]struct {
			result1 *model.Server
		})
	}
	fake.serverReturnsOnCall[i] = struct {
		result1 *model.Server
	}{result1}
}

func (fake *FakeResolvedResource) Service() *model.Service {
	fake.serviceMutex.Lock()
	ret, specificReturn := fake.serviceReturnsOnCall[len(fake.serviceArgsForCall)]
	fake.serviceArgsForCall = append(fake.serviceArgsForCall, struct {
	}{})
	stub := fake.ServiceStub
	fakeReturns := fake.serviceReturns
	fake.recordInvocation("Service", []interface{}{})
	fake.serviceMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResolvedResource) ServiceCallCount() int {
	fake.serviceMutex.RLock()
	defer fake.serviceMutex.RUnlock()
	return len(fake.serviceArgsForCall)
}

func (fake *FakeResolvedResource) ServiceCalls(stub func() *model.Service) {
	fake.serviceMutex.Lock()
	defer fake.serviceMutex.Unlock()
	fake.ServiceStub = stub
}

func (fake *FakeResolvedResource) ServiceReturns(result1 *model.Service) {
	fake.serviceMutex.Lock()
	defer fake.serviceMutex.Unlock()
	fake.ServiceStub = nil
	fake.serviceReturns = struct {
		result1 *model.Service
	}{result1}
}

func (fake *FakeResolvedResource) ServiceReturnsOnCall(i int, result1 *model.Service) {
	fake.serviceMutex.Lock()
	defer fake.serviceMutex.Unlock()
	fake.ServiceStub = nil
	if fake.serviceReturnsOnCall == nil {
		fake.serviceReturnsOnCall = make(map[int]struct {
			result1 *model.Service
		})
	}
	fake.serviceReturnsOnCall[i] = struct {
		result1 *model.Service
	}{result1}
}

func (fake *FakeResolvedResource) URL(arg1 *url.URL, arg2 uritemplates.Vars) (*url.URL, error) {
	fake.uRLMutex.Lock()
	ret, specificReturn := fake.uRLReturnsOnCall[len(fake.uRLArgsForCall)]
	fake.uRLArgsForCall = append(fake.uRLArgsForCall, struct {
		arg1 *url.URL
		arg2 uritemplates.Vars
	}{arg1, arg2})
	stub := fake.URLStub
	fakeReturns := fake.uRLReturns
	fake.recordInvocation("URL", []interface{}{arg1, arg2})
	fake.uRLMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResolvedResource) URLCallCount() int {
	fake.uRLMutex.RLock()
	defer fake.uRLMutex.RUnlock()
	return len(fake.uRLArgsForCall)
}

func (fake *FakeResolvedResource) URLCalls(stub func(*url.URL, uritemplates.Vars) (*url.URL, error)) {
	fake.uRLMutex.Lock()
	defer fake.uRLMutex.Unlock()
	fake.URLStub = stub
}

func (fake *FakeResolvedResource) URLArgsForCall(i int) (*url.URL, uritemplates.Vars) {
	fake.uRLMutex.RLock()
	defer fake.uRLMutex.RUnlock()
	argsForCall := fake.uRLArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResolvedResource) URLReturns(result1 *url.URL, result2 error) {
	fake.uRLMutex.Lock()
	defer fake.uRLMutex.Unlock()
	fake.URLStub = nil
	fake.uRLReturns = struct {
		result1 *url.URL
		result2 error
	}{result1, result2}
}

func (fake *FakeResolvedResource) URLReturnsOnCall(i int, result1 *url.URL, result2 error) {
	fake.uRLMutex.Lock()
	defer fake.uRLMutex.Unlock()
	fake.URLStub = nil
	if fake.uRLReturnsOnCall == nil {
		fake.uRLReturnsOnCall = make(map[int]struct {
			result1 *url.URL
			result2 error
		})
	}
	fake.uRLReturnsOnCall[i] = struct {
		result1 *url.URL
		result2 error
	}{result1, result2}
}

func (fake *FakeResolvedResource) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.bodyMutex.RLock()
	defer fake.bodyMutex.RUnlock()
	fake.endpointMutex.RLock()
	defer fake.endpointMutex.RUnlock()
	fake.headerMutex.RLock()
	defer fake.headerMutex.RUnlock()
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	fake.serverMutex.RLock()
	defer fake.serverMutex.RUnlock()
	fake.serviceMutex.RLock()
	defer fake.serviceMutex.RUnlock()
	fake.uRLMutex.RLock()
	defer fake.uRLMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeResolvedResource) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ model.ResolvedResource = new(FakeResolvedResource)
